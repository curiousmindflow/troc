# Roadmap
1. **Milestone 0: Current status**
  - âœ… troc-core: sans-io layer
  - âœ… troc-core: keyed trait
  - âœ… troc-derive: derive macro attribute to apply Keyed trait
  - âœ… troc: realization layer, using Tokio and Kameo
2. ğŸš§ **Milestone 1: Basic working implementation**
  - âœ… troc-core: minimal unit tests
  - âœ… troc: minimal discovery tests
  - âœ… troc: One Writer one Reader latency benchmark
  - ğŸš§ Basic working DDS implementation
  - ğŸš§ Basic discovery (SPDP, SEDP)
  - ğŸš§ Essentials QoS only:
    - ğŸš§ Reliability
    - ğŸš§ History
    - ğŸš§ Resource Limits
  - ğŸš§ Observability
  - ğŸš§ unit and mutation testing on troc-core
  - ğŸš§ unit and integration testing on troc
  - ğŸš§ CI/CD pipeline
3. ğŸ“‹ **Milestone 2: Production hardening**
  - ğŸ“‹ Performance target achievement
  - ğŸ“‹ property testing where needed
  - ğŸ“‹ fuzzing
  - ğŸ“‹ chaos testing
  - More QoS:
    - ğŸ“‹ Durability
    - ğŸ“‹ Deadline
    - ğŸ“‹ Lifespan
    - ğŸ“‹ Latency budget
4. ğŸ“‹ **Milestone 3: Further**
  - ğŸ“‹ XCDR serialization/deserialization
  - ğŸ“‹ IDL to Rust code generator
  - ğŸ“‹ CLI tool
    - ğŸ“‹ discovery sniffing
    - ğŸ“‹ write and read to/from topics
  - ğŸ“‹ Interoperability

# Experimental
## Gossip protocol based Discovery
The SPDP has been built to support small to medium scale systems. It relies mainly on udp multicast and is somewhat quite simple.

The downside is that SPDP doesn't perform so well on large scale systems, because each time a DomainParticipant is created or discovers another DomainParticipant it emits its "identity" information to all the other DomainParticipants.
We can see that this may quite often induce a discovery storm.
Also, multicast necessitates the infrastructure to support it and adds complexity.

Using a gossip protocol solves those two issues gracefully and brings even other benefits.
Among them, the ability to detect GUID (the unique ID generated by each DomainParticipant at start) collision.

## io_uring
Despite io_uring is not yet integrated into Tokio, there are utility crates that can be used to try a realization layer using this technology and study the potential performance gains.

## Embedded troc-core
Sans-io is great in itself but what about going even further ? what about not relying on the OS ?
For this, troc-core must be completely syscall free which mainly means no memory allocations.
